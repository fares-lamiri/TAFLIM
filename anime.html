<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAFLIM | Ø§Ù„Ø£Ù†Ù…ÙŠ ÙˆØ§Ù„ÙƒØ±ØªÙˆÙ†</title>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <!-- Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ -->
    <header class="navbar">
        <button id="menu-btn" aria-label="ÙØªØ­ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©">
            <span></span>
            <span></span>
            <span></span>
        </button>
        
        <div class="search-container">
            <input type="text" id="search" placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø£Ù†Ù…ÙŠ Ø£Ùˆ ÙƒØ±ØªÙˆÙ†...">
            <div id="search-suggestions" class="search-suggestions"></div>
        </div>
        
        <div class="logo">TAFLIM</div>
    </header>

    <!-- Ø·Ø¨Ù‚Ø© Ø§Ù„ØªØ¹ØªÙŠÙ… -->
    <div id="overlay"></div>

    <!-- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© -->
    <div id="sidebar">
        <button id="close-sidebar">Ã—</button>
        <ul>
            <li><a href="index.html" class="sidebar-link">ğŸ  Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</a></li>
            <li><a href="movies.html" class="sidebar-link">ğŸ¬ Ø§Ù„Ø£ÙÙ„Ø§Ù…</a></li>
            <li><a href="series.html" class="sidebar-link">ğŸ“º Ø§Ù„Ù…Ø³Ù„Ø³Ù„Ø§Øª</a></li>
            <li><a href="anime.html" class="sidebar-link active">ğŸ‡¯ğŸ‡µ Ø§Ù„Ø£Ù†Ù…ÙŠ ÙˆØ§Ù„ÙƒØ±ØªÙˆÙ†</a></li>
        </ul>
    </div>

    <!-- Ø¹Ø±Ø¶ Ø§Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù†Ø´Ø·Ø© -->
    <div id="active-filters" class="active-filters"></div>

    <!-- Ø´Ø±ÙŠØ· Ø§Ù„ÙÙ„Ø§ØªØ± -->
    <div class="filters-bar">
        <div class="filter-group">
            <button class="filter-btn" data-filter="category">ÙØ¦Ø© Ø§Ù„Ø£Ù†Ù…ÙŠ â–¼</button>
            <div class="filter-dropdown">
                <button data-value="">Ø§Ù„ÙƒÙ„</button>
                <button data-value="shonen">Ø´ÙˆÙ†ÙŠÙ† (Shonen)</button>
                <button data-value="shoujo">Ø´ÙˆØ¬Ùˆ (Shoujo)</button>
                <button data-value="seinen">Ø³ÙŠÙ†Ù† (Seinen)</button>
                <button data-value="isekai">Ø¥ÙŠØ³ÙŠÙƒØ§ÙŠ (Isekai)</button>
                <button data-value="mecha">Ù…ÙŠÙƒØ§ (Mecha)</button>
                <button data-value="slice_of_life">Ø´Ø±ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø­ÙŠØ§Ø©</button>
            </div>
        </div>

        <div class="filter-group">
            <button class="filter-btn" data-filter="genre">Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„ÙÙ†ÙŠ â–¼</button>
            <div class="filter-dropdown">
                <button data-value="">Ø§Ù„ÙƒÙ„</button>
                <button data-value="28">Ø£ÙƒØ´Ù†</button>
                <button data-value="12">Ù…ØºØ§Ù…Ø±Ø§Øª</button>
                <button data-value="16">Ø£Ù†ÙŠÙ…ÙŠØ´Ù†</button>
                <button data-value="35">ÙƒÙˆÙ…ÙŠØ¯ÙŠ</button>
                <button data-value="14">ÙØ§Ù†ØªØ§Ø²ÙŠØ§</button>
                <button data-value="878">Ø®ÙŠØ§Ù„ Ø¹Ù„Ù…ÙŠ</button>
                <button data-value="27">Ø±Ø¹Ø¨</button>
                <button data-value="10749">Ø±ÙˆÙ…Ø§Ù†Ø³ÙŠ</button>
                <button data-value="9648">ØºÙ…ÙˆØ¶</button>
                <button data-value="10751">Ø¹Ø§Ø¦Ù„ÙŠ</button>
                <button data-value="10759">Ø£ÙƒØ´Ù† ÙˆÙ…ØºØ§Ù…Ø±Ø§Øª</button>
            </div>
        </div>

        <div class="filter-group">
            <button class="filter-btn" data-filter="year">Ø³Ù†Ø© Ø§Ù„Ø¥ØµØ¯Ø§Ø± â–¼</button>
            <div class="filter-dropdown">
                <button data-value="">Ø§Ù„ÙƒÙ„</button>
                <button data-value="2025">2025</button>
                <button data-value="2024">2024</button>
                <button data-value="2023">2023</button>
                <button data-value="2022">2022</button>
                <button data-value="2021">2021</button>
                <button data-value="2020">2020</button>
                <button data-value="older">Ù‚Ø¨Ù„ 2020</button>
            </div>
        </div>

        <div class="filter-group">
            <button class="filter-btn" data-filter="rating">Ø§Ù„ØªÙ‚ÙŠÙŠÙ… â–¼</button>
            <div class="filter-dropdown">
                <button data-value="">Ø§Ù„ÙƒÙ„</button>
                <button data-value="8">+8 â­â­â­â­</button>
                <button data-value="7">+7 â­â­â­</button>
                <button data-value="6">+6 â­â­</button>
                <button data-value="5">+5 â­</button>
            </div>
        </div>
    </div>

    <!-- Ù‚Ø³Ù… Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« -->
    <div class="search-results-section" id="search-results-section">
        <h2 class="results-title">ğŸ” Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ù†Ù…ÙŠ</h2>
        <div class="search-results-header">
            <div class="search-query-container">
                <span class="search-query-label">Ø¨Ø­Ø«Øª Ø¹Ù†:</span>
                <span class="search-query-text" id="search-query-text"></span>
            </div>
            <div class="search-results-count" id="search-results-count"></div>
        </div>
        <div class="search-results-container" id="search-results-container"></div>
    </div>

    <!-- Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ -->
    <div id="main-content"></div>

    <!-- Ø±Ø³Ø§Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ -->
<!-- Ø±Ø³Ø§Ù„Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ -->
<div style="
    width: 100%;
    min-height: 180px;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    margin-top: 60px;
    margin-bottom: 40px;
    color: #fff;
">

    <div style="font-size: 2.5rem; margin-bottom: 15px;">
        ğŸ‡¯ğŸ‡µ
    </div>

    <div style="font-size: 1.2rem; margin-bottom: 10px;">
        ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…ØªØ§Ø­
    </div>

    <div style="font-size: 0.95rem; color: #888;">
        Ø¬Ø±Ø¨ ØªØºÙŠÙŠØ± Ø§Ù„ÙÙ„Ø§ØªØ± Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ù†Ù…ÙŠ
    </div>

</div>

    <!-- Ø²Ø± Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø£Ø¹Ù„Ù‰ -->
    <button id="back-to-top" class="show">â†‘</button>

    <!-- Ø§Ù„ÙÙˆØªØ± -->
    <footer>
        <div class="footer-content">
            <p>Â© 2025 TAFLIM - Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ‚ Ù…Ø­ÙÙˆØ¸Ø©</p>
            <p class="footer-tagline">ğŸ‡¯ğŸ‡µ ÙˆØ¬Ù‡ØªÙƒ Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø£ÙØ¶Ù„ Ø§Ù„Ø£Ù†Ù…ÙŠ ÙˆØ§Ù„ÙƒØ±ØªÙˆÙ†</p>
        </div>
    </footer>

    <!-- JavaScript -->
    <script>
        // ========== ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…ÙŠ Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø§Ù„Ù„ØºØ§Øª Ø§Ù„Ø°ÙƒÙŠ ==========
        
        // ===== Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø© =====
        const TMDB_API = {
            key: "dbb14198ea29a547de77343dc3fe7a37",
            baseURL: "https://api.themoviedb.org/3",
            imageBase: "https://image.tmdb.org/t/p/w500"
        };

        // ===== Ø¹Ù†Ø§ØµØ± DOM =====
        const mainContent = document.getElementById("main-content");
        const searchInput = document.getElementById("search");
        const suggestionsContainer = document.getElementById("search-suggestions");
        const searchResultsSection = document.getElementById("search-results-section");
        const searchQueryText = document.getElementById("search-query-text");
        const searchResultsCount = document.getElementById("search-results-count");
        const searchResultsContainer = document.getElementById("search-results-container");
        const backToTopBtn = document.getElementById("back-to-top");
        const menuBtn = document.getElementById("menu-btn");
        const sidebar = document.getElementById("sidebar");
        const closeSidebar = document.getElementById("close-sidebar");
        const overlay = document.getElementById("overlay");
        const activeFiltersContainer = document.getElementById("active-filters");
        const endOfContent = document.getElementById("end-of-content");

        // ===== Ù…ØªØºÙŠØ±Ø§Øª Ø­Ø§Ù„Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ =====
        let displayedAnime = [];
        let currentPage = 1;
        let filterPage = 1;
        let isLoading = false;
        let hasMoreAnime = true;
        let searchTimer = null;
        let activeSuggestionIndex = -1;
        let isGlobalSearch = false;
        let activeFilters = {};
        let seenAnimeIds = new Set();

        // ===== Ù‚Ø§Ù…ÙˆØ³ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ Ù„Ù„Ø£Ù†Ù…ÙŠ =====
        const smartSearchDictionary = {
            "Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø¹Ù…Ø§Ù„Ù‚Ø©": "Attack on Titan",
            "Ø³ÙŠÙ Ø§Ù„Ù†Ø§Ø±": "Demon Slayer",
            "Ø¬ÙˆØ¬ÙˆØªØ³Ùˆ ÙƒØ§ÙŠØ³Ù†": "Jujutsu Kaisen",
            "Ø¨Ø·Ù„ÙŠ Ø§Ù„Ø£ÙƒØ§Ø¯ÙŠÙ…ÙŠØ©": "My Hero Academia",
            "ÙˆÙ† Ø¨ÙŠØ³": "One Piece",
            "Ù†Ø§Ø±ÙˆØªÙˆ": "Naruto",
            "Ø¯Ø±Ø§ØºÙˆÙ† Ø¨ÙˆÙ„": "Dragon Ball",
            "Ù…Ù†ØªØ®Ø¨ Ø·ÙˆÙƒÙŠÙˆ": "Tokyo Revengers",
            "Ø£Ø±Ø¶ Ø§Ù„ÙˆØ¹Ø¯": "The Promised Neverland",
            "Ù‡Ø§Ù†ØªØ± Ø§ÙƒØ³ Ù‡Ø§Ù†ØªØ±": "Hunter x Hunter",
            "Ø³Ø§ÙŠÙ„ÙˆØ± Ù…ÙˆÙ†": "Sailor Moon",
            "Ø³ÙˆØ±Ø¯ Ø§Ø±Øª Ø§ÙˆÙ†Ù„Ø§ÙŠÙ†": "Sword Art Online",
            "Ø¨Ù„ÙŠØªØ´": "Bleach",
            "ÙÙŠØ±ÙŠ ØªÙŠÙ„": "Fairy Tail",
            "ÙˆØ§Ù† Ø¨Ø§Ù†Ø´ Ù…Ø§Ù†": "One Punch Man",
            "Ù…ÙˆØ¨ Ø³Ø§ÙŠÙƒÙˆ": "Mob Psycho",
            "ÙØ§ÙŠØ± ÙÙˆØ±Ø³": "Fire Force"
        };

        // ===== Ø¯Ø§Ù„Ø© Ø§Ù„ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø°ÙƒÙŠ =====
        function smartTranslateQuery(query) {
            if (!query || query.trim() === "") return query;
            
            const lowerQuery = query.toLowerCase().trim();
            
            for (const [arabic, english] of Object.entries(smartSearchDictionary)) {
                if (lowerQuery.includes(arabic.toLowerCase())) {
                    console.log(`ğŸ”¤ ØªØ­ÙˆÙŠÙ„ "${arabic}" Ø¥Ù„Ù‰ "${english}"`);
                    return english;
                }
            }
            
            return query;
        }

        // ===== Ù†Ø¸Ø§Ù… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ù„Ù„Ø£Ù†Ù…ÙŠ =====
        function determineAnimeLanguageSettings(originalLanguage) {
            let apiLanguage = 'en-US';
            let titleStrategy = 'english';
            let imageLanguages = 'en,null';
            
            // Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠ: Ø§Ù„Ø±ÙˆÙ…Ø§Ø¬ÙŠ/Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠ
            if (originalLanguage === 'ja') {
                apiLanguage = 'ja-JP';
                titleStrategy = 'romaji';
                imageLanguages = 'ja,null,en';
            } else {
                // Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ù„ØºØ§Øª: Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
                apiLanguage = 'en-US';
                titleStrategy = 'english';
                imageLanguages = 'en,null';
            }
            
            return { apiLanguage, titleStrategy, imageLanguages };
        }

        // ===== Ø¬Ù„Ø¨ ØµÙˆØ±Ø© Ø§Ù„ØºÙ„Ø§Ù Ø§Ù„Ø°ÙƒÙŠØ© Ù„Ù„Ø£Ù†Ù…ÙŠ =====
        async function getSmartPoster(animeId, originalLanguage) {
            const { imageLanguages } = determineAnimeLanguageSettings(originalLanguage);
            const imageUrl = `${TMDB_API.baseURL}/tv/${animeId}/images?api_key=${TMDB_API.key}&include_image_language=${imageLanguages}`;
            
            try {
                const response = await fetch(imageUrl);
                if (!response.ok) throw new Error('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø§Ù„ØµÙˆØ±');
                
                const imageData = await response.json();
                
                if (imageData.posters && imageData.posters.length > 0) {
                    const posterPath = imageData.posters[0].file_path;
                    return `${TMDB_API.imageBase}${posterPath}`;
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ ØµÙˆØ± Ø§Ù„Ø£Ù†Ù…ÙŠ:", error);
            }
            
            return `${TMDB_API.imageBase}/wwemzKWzjKYJFfCeiB57q3r4Bcm.png`;
        }

        // ===== Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ù†Ù…ÙŠ Ù…Ø¹ Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø°ÙƒÙŠ =====
        async function fetchSmartAnimeData(animeId, originalLanguage) {
            const { apiLanguage, titleStrategy } = determineAnimeLanguageSettings(originalLanguage);
            
            const animeUrl = `${TMDB_API.baseURL}/tv/${animeId}?api_key=${TMDB_API.key}&language=${apiLanguage}`;
            
            try {
                const response = await fetch(animeUrl);
                if (!response.ok) throw new Error('ÙØ´Ù„ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ');
                
                const animeData = await response.json();
                let finalTitle = animeData.name || animeData.original_name;
                
                // Ø¥Ø°Ø§ Ø·Ù„Ø¨Øª Ø§Ù„ÙŠØ§Ø¨Ø§Ù†ÙŠØ© ÙˆÙ„Ù… ØªÙˆØ¬Ø¯ ØªØ±Ø¬Ù…Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©
                if (apiLanguage === 'ja-JP' && (!animeData.name || animeData.name === animeData.original_name)) {
                    const englishUrl = `${TMDB_API.baseURL}/tv/${animeId}?api_key=${TMDB_API.key}&language=en-US`;
                    const englishResponse = await fetch(englishUrl);
                    const englishData = await englishResponse.json();
                    finalTitle = englishData.name || animeData.original_name;
                }
                
                const posterUrl = await getSmartPoster(animeId, originalLanguage);
                
                // ØªØ­Ø¯ÙŠØ¯ ØªØµÙ†ÙŠÙ Ø§Ù„Ø£Ù†Ù…ÙŠ
                const category = detectAnimeCategory(finalTitle, animeData.genre_ids || []);
                
                return {
                    id: animeData.id,
                    name: finalTitle,
                    original_name: animeData.original_name,
                    poster_path: posterUrl,
                    backdrop_path: animeData.backdrop_path,
                    overview: animeData.overview,
                    first_air_date: animeData.first_air_date,
                    vote_average: animeData.vote_average,
                    vote_count: animeData.vote_count,
                    genre_ids: animeData.genre_ids || [],
                    original_language: animeData.original_language,
                    popularity: animeData.popularity,
                    type: "anime",
                    category: category
                };
                
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ø°ÙƒÙŠ:", error);
                return null;
            }
        }

        // ===== Ø§ÙƒØªØ´Ø§Ù ØªØµÙ†ÙŠÙ Ø§Ù„Ø£Ù†Ù…ÙŠ =====
        function detectAnimeCategory(title, genreIds) {
            const titleLower = (title || "").toLowerCase();
            
            // Ø´ÙˆÙ†ÙŠÙ†
            if (titleLower.includes('naruto') || titleLower.includes('one piece') || 
                titleLower.includes('dragon ball') || titleLower.includes('my hero academia') ||
                titleLower.includes('demon slayer') || titleLower.includes('jujutsu kaisen')) {
                return "shonen";
            }
            
            // Ø´ÙˆØ¬Ùˆ
            if (titleLower.includes('sailor moon') || titleLower.includes('fruits basket') ||
                titleLower.includes('ouran') || titleLower.includes('vampire knight')) {
                return "shoujo";
            }
            
            // Ø¥ÙŠØ³ÙŠÙƒØ§ÙŠ
            if (titleLower.includes('sword art online') || titleLower.includes('re:zero') ||
                titleLower.includes('overlord') || titleLower.includes('konosuba')) {
                return "isekai";
            }
            
            // Ø³ÙŠÙ†Ù†
            if (titleLower.includes('berserk') || titleLower.includes('vinland saga') ||
                titleLower.includes('monster') || titleLower.includes('ghost in the shell')) {
                return "seinen";
            }
            
            // Ù…ÙŠÙƒØ§
            if (titleLower.includes('gundam') || titleLower.includes('evangelion') ||
                titleLower.includes('code geass') || titleLower.includes('gurren lagann')) {
                return "mecha";
            }
            
            // Ø´Ø±ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø­ÙŠØ§Ø©
            if (genreIds.includes(35) || titleLower.includes('k-on') || 
                titleLower.includes('slice of life') || titleLower.includes('non non biyori')) {
                return "slice_of_life";
            }
            
            return "shonen"; // Ø§ÙØªØ±Ø§Ø¶ÙŠ
        }

        // ===== Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ =====
        async function performSmartSearch(query, page = 1) {
            const translatedQuery = smartTranslateQuery(query);
            
            searchQueryText.textContent = query;
            searchResultsSection.classList.add('active');
            mainContent.style.display = 'none';
            endOfContent.classList.remove('show');
            
            searchResultsContainer.innerHTML = `
                <div class="search-no-results">
                    <div class="loading-spinner"></div>
                    <p>Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† "${query}"...</p>
                </div>
            `;
            
            try {
                const searchUrl = `${TMDB_API.baseURL}/search/tv?api_key=${TMDB_API.key}&query=${encodeURIComponent(translatedQuery)}&language=en-US&page=${page}&with_genres=16`;
                const response = await fetch(searchUrl);
                
                if (!response.ok) throw new Error('ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø«');
                
                const data = await response.json();
                
                if (!data.results || data.results.length === 0) {
                    searchResultsCount.textContent = "0 Ù†ØªÙŠØ¬Ø©";
                    searchResultsContainer.innerHTML = `
                        <div class="search-no-results">
                            <div>ğŸ”</div>
                            <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„Ø¨Ø­Ø« "${query}"</p>
                            <p class="suggestions">Ø¬Ø±Ø¨ ÙƒÙ„Ù…Ø§Øª Ø¨Ø­Ø« Ø£Ø®Ø±Ù‰ Ø£Ùˆ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªÙ‡Ø¬Ø¦Ø©</p>
                        </div>
                    `;
                    return [];
                }
                
                // ØªØµÙÙŠØ© Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø±
                const uniqueResults = [];
                const seenIds = new Set();
                
                for (const item of data.results) {
                    if (!item.poster_path) continue;
                    if (seenIds.has(item.id)) continue;
                    
                    seenIds.add(item.id);
                    uniqueResults.push(item);
                }
                
                searchResultsCount.textContent = `${uniqueResults.length} Ù†ØªÙŠØ¬Ø©`;
                
                // Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„ÙƒÙ„ Ø£Ù†Ù…ÙŠ
                const processedResults = await Promise.all(
                    uniqueResults.map(async (item) => {
                        const animeData = await fetchSmartAnimeData(item.id, item.original_language || 'ja');
                        return animeData;
                    })
                );
                
                const validResults = processedResults.filter(item => item !== null);
                
                if (validResults.length === 0) {
                    searchResultsContainer.innerHTML = `
                        <div class="search-no-results">
                            <div>âš ï¸</div>
                            <p>Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ ØµØ§Ù„Ø­Ø© Ù„Ù„Ø¹Ø±Ø¶</p>
                        </div>
                    `;
                    return [];
                }
                
                return validResults;
                
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ:", error);
                searchResultsContainer.innerHTML = `
                    <div class="search-no-results">
                        <div>âš ï¸</div>
                        <p>Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø«</p>
                        <p class="suggestions">ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</p>
                    </div>
                `;
                return [];
            }
        }

        // ===== Ø¹Ø±Ø¶ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø¨Ø­Ø« =====
        async function showSearchSuggestions(query) {
            if (!query || query.trim().length < 2) {
                suggestionsContainer.style.display = 'none';
                activeSuggestionIndex = -1;
                return;
            }
            
            const translatedQuery = smartTranslateQuery(query);
            
            suggestionsContainer.innerHTML = `
                <div class="no-results">
                    <div>ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† "${query}"...</div>
                </div>
            `;
            suggestionsContainer.style.display = 'block';
            
            try {
                const url = `${TMDB_API.baseURL}/search/tv?api_key=${TMDB_API.key}&query=${encodeURIComponent(translatedQuery)}&language=en-US&page=1&with_genres=16`;
                const response = await fetch(url);
                
                if (!response.ok) return;
                
                const data = await response.json();
                const results = data.results ? data.results.slice(0, 8) : [];
                
                if (results.length === 0) {
                    suggestionsContainer.innerHTML = `
                        <div class="no-results">
                            <div>ğŸ” Ù„Ø§ ØªÙˆØ¬Ø¯ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù„Ù€ "${query}"</div>
                        </div>
                    `;
                    return;
                }
                
                suggestionsContainer.innerHTML = '';
                activeSuggestionIndex = -1;
                
                results.forEach((item, index) => {
                    if (!item.poster_path) return;
                    
                    const div = document.createElement('div');
                    div.className = 'suggestion-item';
                    div.dataset.index = index;
                    
                    const title = item.name || item.original_name || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
                    const year = item.first_air_date ? item.first_air_date.substring(0, 4) : "N/A";
                    
                    const posterUrl = item.poster_path ? 
                        `${TMDB_API.imageBase}${item.poster_path}` : 
                        `${TMDB_API.imageBase}/wwemzKWzjKYJFfCeiB57q3r4Bcm.png`;
                    
                    div.innerHTML = `
                        <img src="${posterUrl}" alt="${title}">
                        <div class="suggestion-info">
                            <div class="suggestion-title">${title}</div>
                            <div class="suggestion-details">ğŸ‡¯ğŸ‡µ Ø£Ù†Ù…ÙŠ â€¢ ${year}</div>
                        </div>
                    `;
                    
                    div.onclick = async () => {
                        const animeData = await fetchSmartAnimeData(item.id, item.original_language || 'ja');
                        if (animeData) {
                            showSingleSearchResult(animeData);
                        }
                    };
                    
                    div.onmouseenter = () => {
                        document.querySelectorAll('.suggestion-item').forEach(s => s.classList.remove('active'));
                        div.classList.add('active');
                        activeSuggestionIndex = index;
                    };
                    
                    suggestionsContainer.appendChild(div);
                });
                
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª:", error);
            }
        }

        // ===== Ø¹Ø±Ø¶ Ù†ØªÙŠØ¬Ø© Ø¨Ø­Ø« ÙˆØ§Ø­Ø¯Ø© =====
        function showSingleSearchResult(animeData) {
            searchQueryText.textContent = animeData.name;
            searchResultsCount.textContent = "1 Ù†ØªÙŠØ¬Ø©";
            searchResultsSection.classList.add('active');
            mainContent.style.display = 'none';
            endOfContent.classList.remove('show');
            searchInput.value = '';
            suggestionsContainer.style.display = 'none';
            
            searchResultsContainer.innerHTML = '';
            const card = createAnimeCard(animeData);
            searchResultsContainer.appendChild(card);
        }

        // ===== Ø¥Ù†Ø´Ø§Ø¡ Ø¨Ø·Ø§Ù‚Ø© Ø£Ù†Ù…ÙŠ =====
        function createAnimeCard(anime) {
            const card = document.createElement("div");
            card.className = "card";
            
            const title = anime.name || "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
            const year = anime.first_air_date ? anime.first_air_date.substring(0, 4) : "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
            const rating = anime.vote_average ? anime.vote_average.toFixed(1) : "N/A";
            const posterUrl = anime.poster_path;
            
            let languageBadge = "";
            if (anime.original_language === 'ja') {
                languageBadge = "ğŸ‡¯ğŸ‡µ ÙŠØ§Ø¨Ø§Ù†ÙŠ";
            } else {
                languageBadge = "ğŸŒ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠ";
            }
            
            let categoryName = "";
            let categoryIcon = "";
            
            switch(anime.category) {
                case 'shonen':
                    categoryName = "Ø´ÙˆÙ†ÙŠÙ†";
                    categoryIcon = "âš”ï¸";
                    break;
                case 'shoujo':
                    categoryName = "Ø´ÙˆØ¬Ùˆ";
                    categoryIcon = "ğŸŒ¸";
                    break;
                case 'seinen':
                    categoryName = "Ø³ÙŠÙ†Ù†";
                    categoryIcon = "ğŸ­";
                    break;
                case 'isekai':
                    categoryName = "Ø¥ÙŠØ³ÙŠÙƒØ§ÙŠ";
                    categoryIcon = "ğŸŒ€";
                    break;
                case 'mecha':
                    categoryName = "Ù…ÙŠÙƒØ§";
                    categoryIcon = "ğŸ¤–";
                    break;
                case 'slice_of_life':
                    categoryName = "Ø´Ø±ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø­ÙŠØ§Ø©";
                    categoryIcon = "â˜•";
                    break;
                default:
                    categoryName = "Ø£Ù†Ù…ÙŠ";
                    categoryIcon = "ğŸ‡¯ğŸ‡µ";
            }
            
            card.innerHTML = `
                <div class="language-badge">${languageBadge}</div>
                <img src="${posterUrl}" alt="${title}" loading="lazy">
                <h3>${title}</h3>
                <div style="padding: 0 12px 12px; display: flex; flex-direction: column; gap: 5px; font-size: 0.8rem;">
                    <div style="display: flex; justify-content: space-between; color: #aaa;">
                        <span>${year}</span>
                        <span>â­ ${rating}</span>
                    </div>
                    <div style="color: #666; text-align: center; font-size: 0.75rem;">
                        ${categoryIcon} ${categoryName}
                    </div>
                </div>
            `;
            
            card.onclick = () => {
                window.location.href = `details.html?type=tv&id=${anime.id}`;
            };
            
            return card;
        }

        // ===== Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ =====
        function setupInfiniteScroll() {
            let scrollTimeout;
            
            window.addEventListener('scroll', () => {
                clearTimeout(scrollTimeout);
                
                scrollTimeout = setTimeout(() => {
                    const scrollPosition = window.scrollY + window.innerHeight;
                    const pageHeight = document.documentElement.scrollHeight - 100;
                    
                    if (scrollPosition >= pageHeight * 0.8 && !isLoading && hasMoreAnime) {
                        if (isGlobalSearch) {
                            loadMoreSearchResults();
                        } else if (Object.keys(activeFilters).length > 0) {
                            loadMoreFilteredAnime();
                        } else {
                            loadMoreAnime();
                        }
                    }
                    
                    backToTopBtn.style.display = window.scrollY > 300 ? "flex" : "none";
                }, 100);
            });
        }

        // ===== Ù†Ø¸Ø§Ù… Ø§Ù„ØªØµÙ†ÙŠÙØ§Øª Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠØ© =====
        function getDiscoverQueryParams() {
            let params = {
                api_key: TMDB_API.key,
                language: 'en-US',
                page: filterPage,
                sort_by: 'popularity.desc',
                with_genres: '16' // Ø§Ù„Ø£Ù†Ù…ÙŠ ÙÙ‚Ø·
            };
            
            // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„Ø§ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ
            if (activeFilters.category) {
                switch(activeFilters.category.value) {
                    case 'shonen':
                        // Ø´ÙˆÙ†ÙŠÙ†: Ø¹Ø§Ø¯Ø© Ù…Ø§ ÙŠÙƒÙˆÙ† Ø£ÙƒØ´Ù† ÙˆÙ…ØºØ§Ù…Ø±Ø§Øª
                        params.with_keywords = '210024|9715';
                        break;
                    case 'shoujo':
                        // Ø´ÙˆØ¬Ùˆ: Ø±ÙˆÙ…Ø§Ù†Ø³ÙŠ
                        params.with_genres = '16,10749';
                        break;
                    case 'seinen':
                        // Ø³ÙŠÙ†Ù†: Ù„Ù„ÙƒØ¨Ø§Ø±
                        params.with_keywords = '9716';
                        break;
                    case 'isekai':
                        // Ø¥ÙŠØ³ÙŠÙƒØ§ÙŠ: Ø¹ÙˆØ§Ù„Ù… Ø¨Ø¯ÙŠÙ„Ø©
                        params.with_keywords = '210024|9717';
                        break;
                    case 'mecha':
                        // Ù…ÙŠÙƒØ§: Ø±ÙˆØ¨ÙˆØªØ§Øª
                        params.with_keywords = '9718';
                        break;
                    case 'slice_of_life':
                        // Ø´Ø±ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø­ÙŠØ§Ø©: ÙƒÙˆÙ…ÙŠØ¯ÙŠ
                        params.with_genres = '16,35';
                        break;
                }
            }
            
            // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„Ø§ØªØ± Ø§Ù„Ù†ÙˆØ¹
            if (activeFilters.genre) {
                params.with_genres = `16,${activeFilters.genre.value}`;
            }
            
            // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„Ø§ØªØ± Ø§Ù„Ø³Ù†Ø©
            if (activeFilters.year) {
                if (activeFilters.year.value === 'older') {
                    params.first_air_date = { lte: '2019-12-31' };
                } else {
                    params.first_air_date_year = activeFilters.year.value;
                }
            }
            
            // ØªØ·Ø¨ÙŠÙ‚ ÙÙ„Ø§ØªØ± Ø§Ù„ØªÙ‚ÙŠÙŠÙ…
            if (activeFilters.rating) {
                params['vote_average.gte'] = activeFilters.rating.value;
            }
            
            return params;
        }

        // ===== Ø¯ÙˆØ§Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ =====
        let searchPage = 1;
        let currentSearchQuery = "";
        
        async function loadMoreSearchResults() {
            if (isLoading || !hasMoreAnime) return;
            
            isLoading = true;
            showLoadingIndicator();
            searchPage++;
            
            try {
                const newResults = await performSmartSearch(currentSearchQuery, searchPage);
                
                if (newResults.length > 0) {
                    newResults.forEach(result => {
                        if (!seenAnimeIds.has(result.id)) {
                            seenAnimeIds.add(result.id);
                            const card = createAnimeCard(result);
                            searchResultsContainer.appendChild(card);
                        }
                    });
                } else {
                    hasMoreAnime = false;
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«:", error);
                hasMoreAnime = false;
            } finally {
                isLoading = false;
                hideLoadingIndicator();
                
                if (!hasMoreAnime) {
                    endOfContent.classList.add('show');
                }
            }
        }

        async function loadMoreAnime() {
            if (isLoading || !hasMoreAnime) return;
            
            isLoading = true;
            showLoadingIndicator();
            currentPage++;
            
            try {
                const url = `${TMDB_API.baseURL}/discover/tv?api_key=${TMDB_API.key}&with_genres=16&language=en-US&page=${currentPage}&sort_by=popularity.desc`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const newAnime = await Promise.all(
                        data.results.map(async (anime) => {
                            if (seenAnimeIds.has(anime.id)) return null;
                            seenAnimeIds.add(anime.id);
                            return await fetchSmartAnimeData(anime.id, anime.original_language || 'ja');
                        })
                    );
                    
                    const validAnime = newAnime.filter(anime => anime !== null);
                    
                    if (validAnime.length > 0) {
                        validAnime.forEach(anime => {
                            const card = createAnimeCard(anime);
                            mainContent.appendChild(card);
                        });
                        displayedAnime = [...displayedAnime, ...validAnime];
                    }
                    
                    hasMoreAnime = currentPage < (data.total_pages || 1);
                } else {
                    hasMoreAnime = false;
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ù†Ù…ÙŠ:", error);
                hasMoreAnime = false;
            } finally {
                isLoading = false;
                hideLoadingIndicator();
                
                if (!hasMoreAnime) {
                    endOfContent.classList.add('show');
                }
            }
        }

        async function loadMoreFilteredAnime() {
            if (isLoading || !hasMoreAnime) return;
            
            isLoading = true;
            showLoadingIndicator();
            filterPage++;
            
            try {
                const params = getDiscoverQueryParams();
                params.page = filterPage;
                
                const queryString = Object.keys(params)
                    .map(key => {
                        if (typeof params[key] === 'object') {
                            return Object.keys(params[key])
                                .map(subKey => `${key}.${subKey}=${params[key][subKey]}`)
                                .join('&');
                        }
                        return `${key}=${encodeURIComponent(params[key])}`;
                    })
                    .join('&');
                
                const url = `${TMDB_API.baseURL}/discover/tv?${queryString}`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const newAnime = await Promise.all(
                        data.results.map(async (anime) => {
                            if (seenAnimeIds.has(anime.id)) return null;
                            seenAnimeIds.add(anime.id);
                            return await fetchSmartAnimeData(anime.id, anime.original_language || 'ja');
                        })
                    );
                    
                    const validAnime = newAnime.filter(anime => anime !== null);
                    
                    if (validAnime.length > 0) {
                        validAnime.forEach(anime => {
                            const card = createAnimeCard(anime);
                            mainContent.appendChild(card);
                        });
                        displayedAnime = [...displayedAnime, ...validAnime];
                    }
                    
                    hasMoreAnime = filterPage < (data.total_pages || 1);
                } else {
                    hasMoreAnime = false;
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ù…ÙÙ„ØªØ±Ø©:", error);
                hasMoreAnime = false;
            } finally {
                isLoading = false;
                hideLoadingIndicator();
                
                if (!hasMoreAnime) {
                    endOfContent.classList.add('show');
                }
            }
        }

        // ===== ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ± =====
        async function applyFilters() {
            displayedAnime = [];
            mainContent.innerHTML = '';
            filterPage = 1;
            hasMoreAnime = true;
            endOfContent.classList.remove('show');
            seenAnimeIds.clear();
            
            showLoadingIndicator();
            
            const params = getDiscoverQueryParams();
            const queryString = Object.keys(params)
                .map(key => `${key}=${encodeURIComponent(params[key])}`)
                .join('&');
            
            const url = `${TMDB_API.baseURL}/discover/tv?${queryString}`;
            
            try {
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const animeList = await Promise.all(
                        data.results.map(async (anime) => {
                            seenAnimeIds.add(anime.id);
                            return await fetchSmartAnimeData(anime.id, anime.original_language || 'ja');
                        })
                    );
                    
                    const validAnime = animeList.filter(anime => anime !== null);
                    
                    if (validAnime.length > 0) {
                        validAnime.forEach(anime => {
                            const card = createAnimeCard(anime);
                            mainContent.appendChild(card);
                        });
                        displayedAnime = validAnime;
                    }
                    
                    hasMoreAnime = filterPage < (data.total_pages || 1);
                    
                    searchResultsSection.classList.remove('active');
                    mainContent.style.display = 'grid';
                    isGlobalSearch = false;
                    
                    updateActiveFiltersDisplay();
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                } else {
                    mainContent.innerHTML = `
                        <div class="search-no-results" style="grid-column:1/-1;">
                            <div style="font-size: 3rem; margin-bottom: 20px;">ğŸ”</div>
                            <div style="font-size: 1.2rem; margin-bottom: 10px;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†ØªØ§Ø¦Ø¬ Ù„Ù„ÙÙ„Ø§ØªØ± Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©</div>
                            <div style="color: #888;">Ø¬Ø±Ø¨ ØªØºÙŠÙŠØ± Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ø¨Ø­Ø« Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙÙ„Ø§ØªØ± Ù…Ø®ØªÙ„ÙØ©</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±:", error);
                mainContent.innerHTML = `
                    <div class="search-no-results" style="grid-column:1/-1;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">âš ï¸</div>
                        <div style="font-size: 1.2rem; margin-bottom: 10px;">Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙÙ„Ø§ØªØ±</div>
                        <div style="color: #888;">ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</div>
                    </div>
                `;
            }
            
            hideLoadingIndicator();
        }

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨Ø­Ø« =====
        function setupSearch() {
            if (!searchInput) return;
            
            searchInput.addEventListener('input', () => {
                clearTimeout(searchTimer);
                
                const query = searchInput.value.trim();
                currentSearchQuery = query;
                
                if (query.length >= 2) {
                    showSearchSuggestions(query);
                } else {
                    suggestionsContainer.style.display = 'none';
                }
                
                searchTimer = setTimeout(async () => {
                    if (query.length === 0) {
                        searchResultsSection.classList.remove('active');
                        mainContent.style.display = 'grid';
                        endOfContent.classList.remove('show');
                        isGlobalSearch = false;
                        searchPage = 1;
                        return;
                    }
                    
                    isGlobalSearch = true;
                    searchPage = 1;
                    seenAnimeIds.clear();
                    
                    const results = await performSmartSearch(query, searchPage);
                    
                    if (results.length > 0) {
                        searchResultsContainer.innerHTML = '';
                        results.forEach(result => {
                            seenAnimeIds.add(result.id);
                            const card = createAnimeCard(result);
                            searchResultsContainer.appendChild(card);
                        });
                        hasMoreAnime = true;
                    }
                }, 500);
            });
            
            searchInput.addEventListener('keydown', (e) => {
                const items = suggestionsContainer.querySelectorAll('.suggestion-item');
                if (items.length === 0) return;
                
                switch(e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        activeSuggestionIndex = (activeSuggestionIndex + 1) % items.length;
                        updateActiveSuggestion(items);
                        break;
                    case 'ArrowUp':
                        e.preventDefault();
                        activeSuggestionIndex = (activeSuggestionIndex - 1 + items.length) % items.length;
                        updateActiveSuggestion(items);
                        break;
                    case 'Enter':
                        if (activeSuggestionIndex >= 0) {
                            e.preventDefault();
                            items[activeSuggestionIndex].click();
                        } else {
                            searchInput.blur();
                        }
                        break;
                    case 'Escape':
                        suggestionsContainer.style.display = 'none';
                        break;
                }
            });
            
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                }
            });
        }

        function updateActiveSuggestion(items) {
            items.forEach((item, index) => {
                item.classList.remove('active');
                if (index === activeSuggestionIndex) {
                    item.classList.add('active');
                    item.scrollIntoView({ block: 'nearest' });
                }
            });
        }

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ÙÙ„Ø§ØªØ± =====
        function setupFilters() {
            document.querySelectorAll('.filter-dropdown button').forEach(item => {
                item.onclick = (e) => {
                    const dropdown = item.closest('.filter-dropdown');
                    if (dropdown) {
                        dropdown.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                        item.classList.add('active');
                        
                        const filterType = dropdown.closest('.filter-group')?.querySelector('.filter-btn')?.dataset.filter;
                        const value = item.dataset.value || "";
                        const displayText = item.textContent;
                        
                        if (value === "") {
                            delete activeFilters[filterType];
                        } else {
                            activeFilters[filterType] = { value, displayText };
                        }
                        
                        dropdown.classList.remove('active');
                        const filterBtn = item.closest('.filter-group')?.querySelector('.filter-btn');
                        if (filterBtn) filterBtn.classList.remove('active');
                        
                        applyFilters();
                        e.stopPropagation();
                    }
                };
            });
        }

        function updateActiveFiltersDisplay() {
            if (!activeFiltersContainer) return;
            
            activeFiltersContainer.innerHTML = '';
            const activeCount = Object.keys(activeFilters).length;
            
            if (activeCount === 0) {
                activeFiltersContainer.style.display = 'none';
                return;
            }
            
            activeFiltersContainer.style.display = 'flex';
            
            const clearBtn = document.createElement('button');
            clearBtn.className = 'clear-all';
            clearBtn.textContent = 'ğŸ—‘ï¸ Ù…Ø³Ø­ Ø§Ù„ÙƒÙ„';
            clearBtn.onclick = clearAllFilters;
            activeFiltersContainer.appendChild(clearBtn);
            
            for (const [type, filter] of Object.entries(activeFilters)) {
                if (!filter || !filter.value) continue;
                
                const tag = document.createElement('div');
                tag.className = 'filter-tag';
                
                const icons = { category: 'ğŸ“', genre: 'ğŸ­', year: 'ğŸ“…', rating: 'â­' };
                const icon = icons[type] || 'ğŸ·ï¸';
                
                tag.innerHTML = `<span>${icon} ${filter.displayText}</span><span class="remove" data-type="${type}">Ã—</span>`;
                tag.querySelector('.remove').onclick = (e) => {
                    e.stopPropagation();
                    removeFilter(type);
                };
                
                activeFiltersContainer.appendChild(tag);
            }
        }

        function removeFilter(type) {
            delete activeFilters[type];
            
            const filterBtn = document.querySelector(`.filter-btn[data-filter="${type}"]`);
            const dropdown = filterBtn.nextElementSibling;
            dropdown.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
            dropdown.querySelector('button[data-value=""]').classList.add('active');
            
            applyFilters();
        }

        function clearAllFilters() {
            document.querySelectorAll('.filter-dropdown').forEach(dropdown => {
                dropdown.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                dropdown.querySelector('button[data-value=""]').classList.add('active');
            });
            
            activeFilters = {};
            displayedAnime = [];
            mainContent.innerHTML = '';
            currentPage = 1;
            filterPage = 1;
            hasMoreAnime = true;
            endOfContent.classList.remove('show');
            seenAnimeIds.clear();
            
            loadInitialAnime();
            updateActiveFiltersDisplay();
        }

        // ===== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© =====
        function showLoadingIndicator() {
            const existingIndicator = document.querySelector('.loading-indicator');
            if (!existingIndicator) {
                const indicator = document.createElement('div');
                indicator.className = 'loading-indicator';
                indicator.style.display = 'block';
                indicator.innerHTML = `
                    <div class="loading-spinner"></div>
                    <div>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ...</div>
                `;
                mainContent.appendChild(indicator);
            }
        }

        function hideLoadingIndicator() {
            const indicator = document.querySelector('.loading-indicator');
            if (indicator) {
                indicator.style.display = 'none';
            }
        }

        // ===== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ø£ÙˆÙ„ÙŠ =====
        async function loadInitialAnime() {
            showLoadingIndicator();
            
            try {
                const url = `${TMDB_API.baseURL}/discover/tv?api_key=${TMDB_API.key}&with_genres=16&language=en-US&page=1&sort_by=popularity.desc`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data.results && data.results.length > 0) {
                    const animeList = await Promise.all(
                        data.results.map(async (anime) => {
                            seenAnimeIds.add(anime.id);
                            return await fetchSmartAnimeData(anime.id, anime.original_language || 'ja');
                        })
                    );
                    
                    const validAnime = animeList.filter(anime => anime !== null);
                    
                    if (validAnime.length > 0) {
                        validAnime.forEach(anime => {
                            const card = createAnimeCard(anime);
                            mainContent.appendChild(card);
                        });
                        displayedAnime = validAnime;
                        hasMoreAnime = true;
                    }
                }
            } catch (error) {
                console.error("âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ø£ÙˆÙ„ÙŠØ©:", error);
                mainContent.innerHTML = `
                    <div class="search-no-results" style="grid-column:1/-1;">
                        <div style="font-size: 3rem; margin-bottom: 20px;">âš ï¸</div>
                        <div style="font-size: 1.2rem; margin-bottom: 10px;">ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠ</div>
                        <div style="color: #888;">ØªØ£ÙƒØ¯ Ù…Ù† Ø§ØªØµØ§Ù„ Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª ÙˆØ­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰</div>
                        <button onclick="location.reload()" style="
                            margin-top: 20px;
                            padding: 10px 20px;
                            background: var(--accent);
                            color: white;
                            border: none;
                            border-radius: 8px;
                            cursor: pointer;
                            font-family: inherit;
                        ">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©</button>
                    </div>
                `;
            }
            
            hideLoadingIndicator();
        }

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¬Ø§Ù†Ø¨ÙŠØ© =====
        function setupSidebar() {
            if (!menuBtn || !sidebar || !overlay || !closeSidebar) return;
            
            menuBtn.onclick = (e) => { 
                e.stopPropagation();
                sidebar.classList.add("show"); 
                overlay.classList.add("show"); 
            };
            
            closeSidebar.onclick = (e) => { 
                e.stopPropagation();
                sidebar.classList.remove("show"); 
                overlay.classList.remove("show"); 
            };
            
            overlay.onclick = (e) => { 
                if (e.target === overlay) {
                    sidebar.classList.remove("show"); 
                    overlay.classList.remove("show"); 
                }
            };
            
            document.querySelectorAll('#sidebar a').forEach(link => {
                link.addEventListener('click', () => {
                    sidebar.classList.remove("show");
                    overlay.classList.remove("show");
                });
            });
        }

        function setupBackToTop() {
            if (!backToTopBtn) return;
            
            backToTopBtn.addEventListener("click", () => {
                window.scrollTo({ top: 0, behavior: "smooth" });
            });
        }

        // ===== Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø© =====
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.onclick = (e) => {
                const dropdown = btn.nextElementSibling;
                const isActive = dropdown.classList.contains('active');

                document.querySelectorAll('.filter-dropdown').forEach(d => d.classList.remove('active'));
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));

                if (!isActive) {
                    dropdown.classList.add('active');
                    btn.classList.add('active');
                }
                e.stopPropagation();
            };
        });

        document.addEventListener('click', () => {
            document.querySelectorAll('.filter-dropdown').forEach(d => d.classList.remove('active'));
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        });

        // ===== ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ =====
        async function initApp() {
            console.log("ğŸ‡¯ğŸ‡µ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø£Ù†Ù…ÙŠ ÙŠØ¹Ù…Ù„...");
            console.log("ğŸ”¤ Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø°ÙƒÙŠ Ø§Ù„Ø¹Ø§Ù„Ù…ÙŠ Ù…ÙØ¹Ù‘Ù„");
            console.log("ğŸŒ Ù†Ø¸Ø§Ù… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© ÙˆØ§Ù„ØµÙˆØ± Ø§Ù„Ø°ÙƒÙŠ Ø¬Ø§Ù‡Ø²");
            
            setupSidebar();
            setupBackToTop();
            setupInfiniteScroll();
            setupFilters();
            setupSearch();
            
            await loadInitialAnime();
            
            console.log("âœ… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…");
        }

        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>